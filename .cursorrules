# ğŸ”¥ Cursor Ruleset - CÃ³digo EscalÃ¡vel e de Alta Qualidade ğŸ”¥

## 1ï¸âƒ£ Estrutura Geral do CÃ³digo
- Todo cÃ³digo gerado deve ser **modular, reutilizÃ¡vel e escalÃ¡vel**.
- Nomeclatura deve seguir padrÃµes da linguagem (camelCase, PascalCase, snake_case).
- CÃ³digo altamente **legÃ­vel e bem comentado**.
- Criar **documentaÃ§Ã£o clara** para cada mÃ³dulo, incluindo exemplos de uso.
- Estruturar projetos de forma **intuitiva e organizada**.
- Sempre seguir princÃ­pios do **SOLID e Clean Code**.
- Priorizar linguagem python para desenvolvimento para resolver problemas de forma prÃ¡tica e eficiente.

## 2ï¸âƒ£ Frontend - Design Minimalista e UX ImpecÃ¡vel
- Utilizar **Atomic Design** para modularizaÃ§Ã£o de componentes.
- Criar **interfaces limpas e responsivas**.
- UX deve seguir princÃ­pios de **Usabilidade do Nielsen**.
- A experiÃªncia do usuÃ¡rio (UX) Ã© prioridade mÃ¡xima.
- Aplicar **design system** para manter consistÃªncia visual.
- CÃ³digo deve estar otimizado para **performance e acessibilidade**.

## 3ï¸âƒ£ Backend - Arquitetura Robusta e SeguranÃ§a
- Aplicar padrÃµes **RESTful** ou **GraphQL**.
- Utilizar **Arquitetura Hexagonal** ou **Clean Architecture** para mÃ¡xima escalabilidade.
- Evitar hardcoded values â€“ sempre usar variÃ¡veis de ambiente.
- Aplicar **camadas de seguranÃ§a** em APIs:
  - Rate limiting
  - JWT / OAuth2 para autenticaÃ§Ã£o
  - Input sanitization para prevenir SQL Injection
- CÃ³digo deve ser **altamente testÃ¡vel** com testes unitÃ¡rios e de integraÃ§Ã£o.

## 4ï¸âƒ£ Banco de Dados - EficiÃªncia e Escalabilidade
- Preferir **PostgreSQL ou MongoDB**, dependendo do caso de uso.
- Criar **Ã­ndices eficientes** para melhorar performance de queries.
- Evitar **N+1 queries** utilizando Eager Loading.
- Aplicar **sharding e partitioning** quando necessÃ¡rio.
- Manter a **normalizaÃ§Ã£o**, mas saber quando **desnormalizar** para performance.

## 5ï¸âƒ£ Performance e AutomaÃ§Ã£o
- **Priorizar caching (Redis, Memcached) para otimizar requisiÃ§Ãµes.**
- Escrever cÃ³digo **assÃ­ncrono sempre que possÃ­vel**.
- Monitorar performance com **logs estruturados** (ELK Stack, Prometheus).
- Criar **pipelines CI/CD** para automaÃ§Ã£o de testes e deploys.
- Utilizar feature flags para lanÃ§amentos seguros.

## 6ï¸âƒ£ Melhores PrÃ¡ticas de Arquitetura e Engenharia de Software
- Aplicar **Domain-Driven Design (DDD)** para organizar o cÃ³digo em domÃ­nios lÃ³gicos.
- Utilizar **Event-Driven Architecture** quando necessÃ¡rio.
- Criar microserviÃ§os apenas se necessÃ¡rio, seguindo o princÃ­pio **"Se puder ser um monÃ³lito eficiente, faÃ§a um monÃ³lito eficiente"**.
- Aplicar princÃ­pios do **Twelve-Factor App** para desenvolvimento escalÃ¡vel na nuvem.

## 7ï¸âƒ£ Qualidade do CÃ³digo e Testes
- **Cobertura de testes mÃ­nima de 80%.**
- Seguir padrÃµes de cÃ³digo como:
  - **ESLint / Prettier** para JavaScript/TypeScript.
  - **Pylint / Black** para Python.
  - **SonarQube** para anÃ¡lise de qualidade.
- **Testes automatizados obrigatÃ³rios** para cada feature.
- Aplicar **TDD (Test-Driven Development)** sempre que possÃ­vel.

## 8ï¸âƒ£ Estrutura de DiretÃ³rios PadrÃ£o
**Node.js / Express**
/project-root â”œâ”€â”€ src/ â”‚ â”œâ”€â”€ controllers/ â”‚ â”œâ”€â”€ services/ â”‚ â”œâ”€â”€ repositories/ â”‚ â”œâ”€â”€ models/ â”‚ â”œâ”€â”€ routes/ â”‚ â”œâ”€â”€ middlewares/ â”‚ â”œâ”€â”€ utils/ â”‚ â”œâ”€â”€ config/ â”‚ â”œâ”€â”€ tests/ â”œâ”€â”€ public/ â”œâ”€â”€ views/ â”œâ”€â”€ logs/ â”œâ”€â”€ docker/ â”œâ”€â”€ .env â”œâ”€â”€ .gitignore â”œâ”€â”€ README.md
**React / Next.js**
/project-root â”œâ”€â”€ src/ â”‚ â”œâ”€â”€ components/ â”‚ â”œâ”€â”€ hooks/ â”‚ â”œâ”€â”€ context/ â”‚ â”œâ”€â”€ pages/ â”‚ â”œâ”€â”€ styles/ â”‚ â”œâ”€â”€ utils/ â”‚ â”œâ”€â”€ tests/ â”œâ”€â”€ public/ â”œâ”€â”€ .next/ â”œâ”€â”€ .env â”œâ”€â”€ .gitignore â”œâ”€â”€ README.md

## 9ï¸âƒ£ SeguranÃ§a de CÃ³digo
- Sempre validar **entradas de usuÃ¡rio** antes de processÃ¡-las.
- Nunca expor **chaves API ou credenciais** no cÃ³digo.
- Aplicar **autenticaÃ§Ã£o forte e criptografia** (bcrypt, AES-256).
- Criar logs detalhados **sem vazar informaÃ§Ãµes sensÃ­veis**.

## ğŸ”Ÿ AtualizaÃ§Ãµes e EvoluÃ§Ã£o do CÃ³digo
- O cÃ³digo deve ser **fÃ¡cil de manter e evoluir**.
- RevisÃµes devem seguir o modelo de **Pull Requests com Code Review rigoroso**.
- O uso de IA no desenvolvimento deve seguir a diretriz:
  - Gerar cÃ³digo **de alta qualidade e explicÃ¡vel**.
  - **Evitar dependÃªncia excessiva** de soluÃ§Ãµes black-box.

# ğŸ”¥ SEGUIR ESSAS REGRAS Ã‰ OBRIGATÃ“RIO ğŸ”¥